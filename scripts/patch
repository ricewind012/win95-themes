#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";
import process from "node:process";

const THEME_ITEM_HEIGHT = 16;
const VSCODE_ITEM_HEIGHT = 22;

const prog = process.argv[2];
let file = "";
let patches = [];
switch (prog) {
	case "vscode":
		file = "/usr/lib/code/out/vs/workbench/workbench.desktop.main.js";
		patches = [
			// I. List item height
			[
				new RegExp(`(ITEM_HEIGHT=)${VSCODE_ITEM_HEIGHT}`),
				`$1${THEME_ITEM_HEIGHT}`,
			],
			[
				new RegExp(`(getHeight\(i?\){return )${VSCODE_ITEM_HEIGHT}`),
				`$1${THEME_ITEM_HEIGHT}`,
			],

			// II. Scrollbar arrows
			// I can't tell if it's intentionally applied only to the editor, or
			// if it's just a bug... No point in making an issue, as the
			// scrollbar arrows are undocumented anyway.
			[/(arrowSize:)\d+/, "$1 16"],
			[/\w\.verticalHasArrows/, "true"],
			[/(verticalHasArrows:)!1/, "$1 true"],
			[/\w\.horizontalHasArrows/, "true"],
			[/(horizontalHasArrows:)!1/, "$1 true"],
		];
		break;

	// All patches here MUST match the original string's size or else Steam will
	// revert them!
	case "steam": {
		const fill = (n) => Array(n.length).fill("0").join("");

		file = path.join(
			process.env.HOME,
			".steam",
			"steam",
			"steamui",
			"chunk~2dcc5aaf7.js",
		);
		patches = [
			// I. Library sidebar
			[/(bIsCollection,)26/, `$1${THEME_ITEM_HEIGHT}`],
			// II. Screenshot manager dialog
			[
				/(gridGapPx:")(\d+)(px",desktopTopPadding:")(\d+)/,
				(_, s1, s2, s3, s4) => `${s1}${fill(s2)}${s3}${fill(s4)}`,
			],
			// III. Server browser (context - "estimateSize")
			[/34\),\[34\]/, `${THEME_ITEM_HEIGHT}),[${THEME_ITEM_HEIGHT}]`],

			// IV. GAME RECORDING
			// Align file size for Math.round() (safe - prop used only once)
			[/globalOffsetPX/g, "OffsetPX"],
			// Fix blurred ticks in game recording dialog
			[
				/(\w+=)(\w+\+\w+\*\w+)(,\w+=`\${\w+\+\w+\*\w+}`;\w+\.push\({key:\w+,offsetPX:\w+)/g,
				(_, s1, s2, s3) => `${s1}Math.round(${s2})${s3}`,
			],
		];
		break;
	}
}

let content = fs.readFileSync(file).toString();
fs.writeFileSync(`${file}.bak`, content);
for (const [a, b] of patches) {
	content = content.replace(a, b);
}
fs.writeFileSync(file, content);
